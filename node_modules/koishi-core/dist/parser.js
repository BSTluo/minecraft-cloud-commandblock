"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const koishi_utils_1 = require("koishi-utils");
const ANGLED_BRACKET_REGEXP = /<([^>]+)>/g;
const SQUARE_BRACKET_REGEXP = /\[([^\]]+)\]/g;
function removeBrackets(source) {
    return source.replace(/[<[].+/, '').trim();
}
exports.removeBrackets = removeBrackets;
function parseBracket(name, required) {
    let variadic = false, noSegment = false;
    if (name.startsWith('...')) {
        name = name.slice(3);
        variadic = true;
    }
    else if (name.endsWith('...')) {
        name = name.slice(0, -3);
        noSegment = true;
    }
    return {
        name,
        required,
        variadic,
        noSegment,
    };
}
function parseArguments(source) {
    let capture;
    const result = [];
    while ((capture = ANGLED_BRACKET_REGEXP.exec(source))) {
        result.push(parseBracket(capture[1], true));
    }
    while ((capture = SQUARE_BRACKET_REGEXP.exec(source))) {
        result.push(parseBracket(capture[1], false));
    }
    return result;
}
exports.parseArguments = parseArguments;
function parseOption(rawName, description, config, optsDef) {
    config = { authority: 0, ...config };
    const negated = [];
    const camels = [];
    let required = false, isBoolean = false, longest = '';
    const names = removeBrackets(rawName).split(',').map((name) => {
        name = name.trim().replace(/^-{1,2}/, '');
        let camel;
        if (name.startsWith('no-') && !config.noNegated && !optsDef[name.slice(3)]) {
            name = name.slice(3);
            camel = koishi_utils_1.camelCase(name);
            negated.push(camel);
        }
        else {
            camel = koishi_utils_1.camelCase(name);
        }
        camels.push(camel);
        if (camel.length > longest.length)
            longest = camel;
        return name;
    });
    if (rawName.includes('<')) {
        required = true;
    }
    else if (!rawName.includes('[')) {
        isBoolean = true;
    }
    return {
        ...config,
        rawName,
        longest,
        names,
        camels,
        negated,
        required,
        isBoolean,
        description,
    };
}
exports.parseOption = parseOption;
// eslint-disable-next-line quotes
const quotes = `"'“”‘’`;
function parseRest(source) {
    if (quotes.includes(source[0]) && quotes.includes(source[source.length - 1]))
        return source.slice(1, -1);
    return source;
}
function parseArg0(source) {
    if (quotes.includes(source[0])) {
        const [content] = source.slice(1).split(/["'“”](?=\s|$)/, 1);
        return {
            quoted: true,
            content,
            rest: source.slice(2 + content.length).trimLeft(),
        };
    }
    const [content] = source.split(/\s/, 1);
    return { content, quoted: false, rest: source.slice(content.length).trimLeft() };
}
function parseValue(source, quoted, config = {}) {
    // quoted empty string
    if (source === '' && quoted)
        return '';
    // no explicit parameter
    if (source === true || source === '') {
        if (config.default !== undefined)
            return config.default;
        if (config.isString)
            return '';
        return true;
    }
    // default behavior
    if (config.isString)
        return source;
    const n = +source;
    return n * 0 === 0 ? n : source;
}
exports.parseValue = parseValue;
function parseLine(source, argsDef, optsDef) {
    let arg, name, arg0, rest = '';
    const args = [];
    const unknown = [];
    const options = {};
    function handleOption(name, knownValue, unknownValue) {
        const config = optsDef[name];
        if (config) {
            for (const alias of config.camels) {
                options[alias] = !config.negated.includes(alias) && knownValue;
            }
        }
        else {
            // unknown option name
            options[koishi_utils_1.camelCase(name)] = unknownValue;
            if (!unknown.includes(name)) {
                unknown.push(name);
            }
        }
    }
    while (source) {
        // long argument
        if (source[0] !== '-' && argsDef[args.length] && argsDef[args.length].noSegment) {
            args.push(parseRest(source));
            break;
        }
        // parse argv0
        arg0 = parseArg0(source);
        arg = arg0.content;
        source = arg0.rest;
        if (arg[0] !== '-' || arg0.quoted) {
            // normal argument
            args.push(arg);
            continue;
        }
        else if (arg === '--') {
            // rest part
            rest = parseRest(arg0.rest);
            break;
        }
        // find -
        let i = 0;
        for (; i < arg.length; ++i) {
            if (arg.charCodeAt(i) !== 45)
                break;
        }
        if (arg.slice(i, i + 3) === 'no-' && !optsDef[arg.slice(i)]) {
            name = arg.slice(i + 3);
            handleOption(name, true, false);
            continue;
        }
        // find =
        let j = i + 1;
        for (; j < arg.length; j++) {
            if (arg.charCodeAt(j) === 61)
                break;
        }
        name = arg.slice(i, j);
        const names = i === 2 ? [name] : name;
        // get parameter
        let quoted = false;
        let param = arg.slice(++j);
        const lastConfig = optsDef[names[names.length - 1]];
        if (!param && source.charCodeAt(0) !== 45 && (!lastConfig || !lastConfig.isBoolean)) {
            arg0 = parseArg0(source);
            param = arg0.content;
            quoted = arg0.quoted;
            source = arg0.rest;
        }
        // handle each name
        for (j = 0; j < names.length; j++) {
            name = names[j];
            const config = optsDef[name];
            const value = parseValue((j + 1 < names.length) || param, quoted, config);
            handleOption(name, value, value);
        }
    }
    // assign default values
    for (const name in optsDef) {
        if (optsDef[name].default !== undefined && !(name in options)) {
            options[name] = optsDef[name].default;
        }
    }
    return { options, rest, unknown, args };
}
exports.parseLine = parseLine;

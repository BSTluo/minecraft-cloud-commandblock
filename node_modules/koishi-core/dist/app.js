"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
const sender_1 = require("./sender");
const server_1 = require("./server");
const command_1 = require("./command");
const context_1 = require("./context");
const database_1 = require("./database");
const utils_1 = require("./utils");
const koishi_utils_1 = require("koishi-utils");
const messages_1 = require("./messages");
const selfIds = new Set();
exports.appMap = {};
exports.appList = [];
const onStartHooks = new Set();
function onStart(hook) {
    onStartHooks.add(hook);
}
exports.onStart = onStart;
const onStopHooks = new Set();
function onStop(hook) {
    onStopHooks.add(hook);
}
exports.onStop = onStop;
async function startAll() {
    await Promise.all(exports.appList.map(async (app) => app.start()));
}
exports.startAll = startAll;
async function stopAll() {
    await Promise.all(exports.appList.map(async (app) => app.stop()));
}
exports.stopAll = stopAll;
let getSelfIdsPromise;
async function getSelfIds() {
    if (!getSelfIdsPromise) {
        getSelfIdsPromise = Promise.all(exports.appList.map(async (app) => {
            if (app.selfId || !app.options.type)
                return;
            const info = await app.sender.getLoginInfo();
            app.prepare(info.userId);
        }));
    }
    await getSelfIdsPromise;
    return Array.from(selfIds);
}
exports.getSelfIds = getSelfIds;
const appScope = [[null, []], [null, []], [null, []]];
const appIdentifier = context_1.ContextScope.stringify(appScope);
const nicknameSuffix = '([,ï¼Œ]\\s*|\\s+)';
function createLeadingRE(patterns, prefix = '', suffix = '') {
    return patterns.length ? new RegExp(`^${prefix}(${patterns.map(escape_string_regexp_1.default).join('|')})${suffix}`) : /^/;
}
const defaultOptions = {
    maxMiddlewares: 64,
    retryInterval: 5000,
};
var Status;
(function (Status) {
    Status[Status["closed"] = 0] = "closed";
    Status[Status["opening"] = 1] = "opening";
    Status[Status["open"] = 2] = "open";
    Status[Status["closing"] = 3] = "closing";
})(Status = exports.Status || (exports.Status = {}));
class App extends context_1.Context {
    constructor(options = {}) {
        super(appIdentifier, appScope);
        this.app = this;
        this.status = Status.closed;
        this._commands = [];
        this._commandMap = {};
        this._shortcuts = [];
        this._shortcutMap = {};
        this._middlewares = [];
        this._isReady = false;
        this._middlewareCounter = 0;
        this._middlewareSet = new Set();
        this._contexts = { [appIdentifier]: this };
        this._preprocess = async (meta, next) => {
            var _a;
            // strip prefix
            let capture;
            let atMe = false;
            let nickname = '';
            let prefix = null;
            let message = koishi_utils_1.simplify(meta.message.trim());
            if (meta.messageType !== 'private' && (capture = message.match(this.atMeRE))) {
                atMe = true;
                nickname = capture[0];
                message = message.slice(capture[0].length);
            }
            if ((_a = (capture = message.match(this.nicknameRE))) === null || _a === void 0 ? void 0 : _a[0].length) {
                nickname = capture[0];
                message = message.slice(capture[0].length);
            }
            // eslint-disable-next-line no-cond-assign
            if (capture = message.match(this.prefixRE)) {
                prefix = capture[0];
                message = message.slice(capture[0].length);
            }
            // store parsed message
            Object.defineProperty(meta, '$parsed', {
                writable: true,
                value: { atMe, nickname, prefix, message },
            });
            // parse as command
            if (!meta.$argv && (prefix !== null || nickname || meta.messageType === 'private')) {
                Object.defineProperty(meta, '$argv', {
                    writable: true,
                    value: this.parseCommandLine(message, meta),
                });
            }
            // parse as shortcut
            if (!meta.$argv && !prefix) {
                for (const shortcut of this._shortcuts) {
                    const { name, fuzzy, command, oneArg, prefix, options, args = [] } = shortcut;
                    if (prefix && !nickname)
                        continue;
                    if (!fuzzy && message !== name)
                        continue;
                    if (message.startsWith(name)) {
                        const _message = message.slice(name.length);
                        if (fuzzy && !nickname && _message.match(/^\S/))
                            continue;
                        const result = oneArg
                            ? { rest: '', options: {}, unknown: [], args: [_message.trim()] }
                            : command.parse(_message.trim());
                        result.options = { ...options, ...result.options };
                        result.args.unshift(...args);
                        Object.defineProperty(meta, '$argv', {
                            writable: true,
                            value: { meta, command, ...result },
                        });
                        break;
                    }
                }
            }
            if (!meta.$argv) {
                Object.defineProperty(meta, '$argv', {
                    writable: true,
                    value: { meta },
                });
            }
            const { command } = meta.$argv;
            if (this.database) {
                if (meta.messageType === 'group') {
                    // attach group data
                    const group = await this._attachGroup(meta, ['flag', 'assignee']);
                    // emit attach event
                    this.emitEvent(meta, 'attach-group', meta);
                    // ignore some group calls
                    const isAssignee = !group.assignee || group.assignee === this.selfId;
                    const noCommand = group.flag & database_1.GroupFlag.noCommand;
                    const noResponse = group.flag & database_1.GroupFlag.noResponse || !isAssignee;
                    if (noCommand && command)
                        return;
                    if (noResponse && !atMe)
                        return;
                    const originalNext = next;
                    next = (fallback) => noResponse || originalNext(fallback);
                }
                // attach user data
                const user = await this._attachUser(meta, ['flag']);
                // emit attach event
                this.emitEvent(meta, 'attach', meta);
                this.emitEvent(meta, 'attach-user', meta);
                // ignore some user calls
                if (user.flag & database_1.UserFlag.ignore)
                    return;
            }
            // execute command
            if (command && !command.getConfig('disable', meta)) {
                return command.execute(meta.$argv, next);
            }
            // show suggestions
            const target = message.split(/\s/, 1)[0].toLowerCase();
            if (!target || !capture || command)
                return next();
            const executableMap = new Map();
            return utils_1.showSuggestions({
                target,
                meta,
                next,
                prefix: messages_1.messages.COMMAND_SUGGESTION_PREFIX,
                suffix: messages_1.messages.COMMAND_SUGGESTION_SUFFIX,
                items: Object.keys(this._commandMap),
                coefficient: this.options.similarityCoefficient,
                command: suggestion => this._commandMap[suggestion],
                disable: (name) => {
                    const command = this._commandMap[name];
                    let disabled = executableMap.get(command);
                    if (disabled === undefined) {
                        disabled = !!command.getConfig('disable', meta);
                        executableMap.set(command, disabled);
                    }
                    return disabled;
                },
                execute: async (suggestion, meta, next) => {
                    const newMessage = suggestion + message.slice(target.length);
                    const argv = this.parseCommandLine(newMessage, meta);
                    return argv.command.execute(argv, next);
                },
            });
        };
        this._applyMiddlewares = async (meta) => {
            var _a, _b;
            // preparation
            const counter = this._middlewareCounter++;
            this._middlewareSet.add(counter);
            const middlewares = this._middlewares
                .filter(([context]) => context.match(meta))
                .map(([_, middleware]) => middleware);
            // execute middlewares
            let index = 0;
            const next = async (fallback) => {
                var _a;
                if (!this._middlewareSet.has(counter)) {
                    return this.logger('koishi').warn(new Error(messages_1.errors.ISOLATED_NEXT));
                }
                if (fallback)
                    middlewares.push((_, next) => fallback(next));
                try {
                    return (_a = middlewares[index++]) === null || _a === void 0 ? void 0 : _a.call(middlewares, meta, next);
                }
                catch (error) {
                    this.receiver.emit('error/middleware', error);
                    this.receiver.emit('error', error);
                }
            };
            await next();
            // update middleware set
            this._middlewareSet.delete(counter);
            this.emitEvent(meta, 'after-middleware', meta);
            // flush user & group data
            await ((_a = meta.$user) === null || _a === void 0 ? void 0 : _a._update());
            await ((_b = meta.$group) === null || _b === void 0 ? void 0 : _b._update());
        };
        // resolve options
        this.options = { ...defaultOptions, ...options };
        if (options.database && Object.keys(options.database).length) {
            this.database = database_1.createDatabase(options.database);
        }
        if (!options.type && typeof options.server === 'string') {
            this.options.type = this.options.server.split(':', 1)[0];
        }
        if (this.options.type) {
            this.server = server_1.createServer(this);
            this.sender = new sender_1.Sender(this);
        }
        // register application
        exports.appList.push(this);
        if (this.selfId)
            this.prepare();
        // bind built-in event listeners
        this.receiver.on('message', this._applyMiddlewares);
        this.receiver.on('before-user', command_1.Command.attachUserFields);
        this.receiver.on('before-group', command_1.Command.attachGroupFields);
        this.middleware(this._preprocess);
        // apply default logger
        this.receiver.on('logger', (scope, message) => debug_1.default(scope)(message));
    }
    get users() {
        if (this._users)
            return this._users;
        const users = this.createContext([[null, []], [[], null], [[], null]]);
        users.except = (...ids) => this.createContext([[null, ids], [[], null], [[], null]]);
        return this._users = users;
    }
    get groups() {
        if (this._groups)
            return this._groups;
        const groups = this.createContext([[[], null], [null, []], [[], null]]);
        groups.except = (...ids) => this.createContext([[[], null], [null, ids], [[], null]]);
        return this._groups = groups;
    }
    get discusses() {
        if (this._discusses)
            return this._discusses;
        const discusses = this.createContext([[[], null], [[], null], [null, []]]);
        discusses.except = (...ids) => this.createContext([[[], null], [[], null], [null, ids]]);
        return this._discusses = discusses;
    }
    get selfId() {
        return this.options.selfId;
    }
    get version() {
        var _a;
        return (_a = this.server) === null || _a === void 0 ? void 0 : _a.version;
    }
    prepare(selfId) {
        if (selfId) {
            this.options.selfId = selfId;
            if (!this._isReady && this.server.isListening) {
                this.receiver.emit('ready');
                this._isReady = true;
            }
        }
        exports.appMap[this.selfId] = this;
        selfIds.add(this.selfId);
        if (this.server) {
            this.server.appMap[this.selfId] = this;
        }
        const { nickname, commandPrefix } = this.options;
        const nicknames = Array.isArray(nickname) ? nickname : nickname ? [nickname] : [];
        const prefixes = Array.isArray(commandPrefix) ? commandPrefix : [commandPrefix || ''];
        this.atMeRE = new RegExp(`^\\[CQ:at,qq=${this.selfId}\\]${nicknameSuffix}`);
        this.nicknameRE = createLeadingRE(nicknames, '@?', nicknameSuffix);
        this.prefixRE = createLeadingRE(prefixes);
    }
    destroy() {
        const index = exports.appList.indexOf(this);
        if (index >= 0)
            exports.appList.splice(index, 1);
        delete exports.appMap[this.selfId];
        selfIds.delete(this.selfId);
        if (this.server) {
            const index = this.server.appList.indexOf(this);
            if (index >= 0)
                this.server.appList.splice(index, 1);
            delete this.server.appMap[this.selfId];
        }
    }
    createContext(scope) {
        if (typeof scope === 'string')
            scope = context_1.ContextScope.parse(scope);
        scope = scope.map(([include, exclude]) => {
            return include ? [include.sort(), exclude] : [include, exclude.sort()];
        });
        const identifier = context_1.ContextScope.stringify(scope);
        if (!this._contexts[identifier]) {
            const ctx = this._contexts[identifier] = new context_1.Context(identifier, scope);
            ctx.database = this.database;
            ctx.sender = this.sender;
            ctx.app = this;
        }
        return this._contexts[identifier];
    }
    discuss(...ids) {
        return this.createContext([[[], null], [[], null], [ids, null]]);
    }
    group(...ids) {
        return this.createContext([[[], null], [ids, null], [[], null]]);
    }
    user(...ids) {
        return this.createContext([[ids, null], [[], null], [[], null]]);
    }
    async start() {
        var _a, _b;
        this.status = Status.opening;
        this.receiver.emit('before-connect');
        const tasks = [];
        if (this.database) {
            for (const type in this.options.database) {
                tasks.push((_b = (_a = this.database[type]) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
        }
        if (this.server) {
            tasks.push(this.server.listen());
        }
        await Promise.all(tasks);
        this.status = Status.open;
        this.logger('koishi:app').debug('started');
        this.receiver.emit('connect');
        if (this.selfId && !this._isReady) {
            this.receiver.emit('ready');
            this._isReady = true;
        }
        if (exports.appList.every(app => app.status === Status.open)) {
            onStartHooks.forEach(hook => hook(...exports.appList));
        }
    }
    async stop() {
        var _a, _b;
        this.status = Status.closing;
        this.receiver.emit('before-disconnect');
        const tasks = [];
        if (this.database) {
            for (const type in this.options.database) {
                tasks.push((_b = (_a = this.database[type]) === null || _a === void 0 ? void 0 : _a.stop) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
        }
        await Promise.all(tasks);
        if (this.server) {
            this.server.close();
        }
        this.status = Status.closed;
        this.logger('koishi:app').debug('stopped');
        this.receiver.emit('disconnect');
        if (exports.appList.every(app => app.status === Status.closed)) {
            onStopHooks.forEach(hook => hook(...exports.appList));
        }
    }
    emitEvent(meta, event, ...payload) {
        if (!meta.$ctxType) {
            this.logger('koishi:receiver').debug('/', 'emits', event);
            this.receiver.emit(event, ...payload);
            return;
        }
        for (const path in this._contexts) {
            const context = this._contexts[path];
            if (!context.match(meta))
                continue;
            this.logger('koishi:receiver').debug(path, 'emits', event);
            context.receiver.emit(event, ...payload);
        }
    }
    parseCommandLine(message, meta) {
        const name = message.split(/\s/, 1)[0];
        const command = this._getCommandByRawName(name);
        if (command === null || command === void 0 ? void 0 : command.context.match(meta)) {
            const result = command.parse(message.slice(name.length).trimStart());
            return { meta, command, ...result };
        }
    }
    async _attachGroup(meta, fields = []) {
        const groupFields = new Set(fields);
        this.emitEvent(meta, 'before-group', groupFields, meta.$argv);
        const group = await this.database.observeGroup(meta.groupId, Array.from(groupFields));
        Object.defineProperty(meta, '$group', { value: group, writable: true });
        return group;
    }
    async _attachUser(meta, fields = []) {
        const userFields = new Set(fields);
        this.emitEvent(meta, 'before-user', userFields, meta.$argv);
        const defaultAuthority = typeof this.options.defaultAuthority === 'function'
            ? this.options.defaultAuthority(meta)
            : this.options.defaultAuthority || 0;
        const user = meta.anonymous
            ? koishi_utils_1.observe(database_1.createUser(meta.userId, defaultAuthority))
            : await this.database.observeUser(meta.userId, defaultAuthority, Array.from(userFields));
        Object.defineProperty(meta, '$user', { value: user, writable: true });
        return user;
    }
    async executeCommandLine(message, meta, next = koishi_utils_1.noop) {
        if (!('$ctxType' in meta))
            this.server.parseMeta(meta);
        const argv = this.parseCommandLine(message, meta);
        if (!argv)
            return next();
        Object.defineProperty(meta, '$argv', {
            writable: true,
            value: argv,
        });
        if (this.database) {
            if (meta.messageType === 'group') {
                await this._attachGroup(meta);
            }
            await this._attachUser(meta);
        }
        if (argv.command.getConfig('disable', meta))
            return next();
        return argv.command.execute(argv, next);
    }
}
exports.App = App;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const util_1 = require("util");
const misc_1 = require("./misc");
const showObserverLog = debug_1.default('koishi:observer');
const staticTypes = ['number', 'string', 'bigint', 'boolean', 'symbol', 'function'];
const builtinClasses = ['Date', 'RegExp', 'Set', 'Map', 'WeakSet', 'WeakMap', 'Array'];
const refs = {};
function observeProperty(value, proxy, key, label, update) {
    if (util_1.types.isDate(value)) {
        return proxy[key] = observeDate(value, update);
    }
    else if (Array.isArray(value)) {
        return proxy[key] = observeArray(value, label, update);
    }
    else {
        return proxy[key] = observeObject(value, label, update);
    }
}
function observeObject(target, label, update) {
    if (!target['__proxyGetters__']) {
        Object.defineProperty(target, '__proxyGetters__', { value: {} });
    }
    if (!update) {
        Object.defineProperty(target, '_diff', { value: {}, writable: true });
    }
    return new Proxy(target, {
        get(target, key) {
            if (key in target.__proxyGetters__)
                return target.__proxyGetters__[key];
            const value = target[key];
            if (!value || staticTypes.includes(typeof value) || typeof key === 'string' && key.startsWith('_'))
                return value;
            const _update = update || (() => {
                const hasKey = key in target._diff;
                target._diff[key] = target.__proxyGetters__[key];
                if (!hasKey && label) {
                    showObserverLog(`[diff] ${label}: ${String(key)} (deep)`);
                }
            });
            return observeProperty(value, target.__proxyGetters__, key, label, _update);
        },
        set(target, key, value) {
            if (target[key] !== value) {
                if (update) {
                    update();
                }
                else if (typeof key !== 'string' || !key.startsWith('_')) {
                    const hasKey = key in target._diff;
                    target._diff[key] = value;
                    delete target.__proxyGetters__[key];
                    if (!hasKey && label) {
                        showObserverLog(`[diff] ${label}: ${String(key)}`);
                    }
                }
            }
            return Reflect.set(target, key, value);
        },
        deleteProperty(target, key) {
            if (update) {
                update();
            }
            else {
                delete target._diff[key];
            }
            return Reflect.deleteProperty(target, key);
        },
    });
}
const arrayProxyMethods = ['pop', 'shift', 'splice'];
function observeArray(target, label, update) {
    const proxy = {};
    for (const method of arrayProxyMethods) {
        Object.defineProperty(target, method, {
            writable: true,
            value(...args) {
                update();
                return Array.prototype[method].apply(this, args);
            },
        });
    }
    return new Proxy(target, {
        get(target, key) {
            if (key in proxy)
                return proxy[key];
            const value = target[key];
            if (!value || staticTypes.includes(typeof value) || typeof key === 'symbol' || isNaN(key))
                return value;
            return observeProperty(value, proxy, key, label, update);
        },
        set(target, key, value) {
            if (typeof key !== 'symbol' && !isNaN(key) && target[key] !== value)
                update();
            return Reflect.set(target, key, value);
        },
    });
}
function observeDate(target, update) {
    for (const method in Date.prototype) {
        if (!method.startsWith('set'))
            continue;
        Object.defineProperty(target, method, {
            writable: true,
            value(...args) {
                update();
                return Array.prototype[method].apply(this, args);
            },
        });
    }
    return target;
}
function observe(target, ...args) {
    if (staticTypes.includes(typeof target)) {
        throw new Error(`cannot observe type "${typeof target}"`);
    }
    else if (!target) {
        throw new Error('cannot observe null or undefined');
    }
    else {
        const type = Object.prototype.toString.call(target).slice(8, -1);
        if (builtinClasses.includes(type)) {
            throw new Error(`cannot observe instance of type "${type}"`);
        }
    }
    let label = '', update;
    if (typeof args[0] === 'function')
        update = args.shift();
    if (typeof args[0] === 'string')
        label = args[0];
    if (label && label in refs) {
        refs[label].__updateCallback__ = update || refs[label].__updateCallback__;
        return refs[label]._merge(target);
    }
    Object.defineProperty(target, '__updateCallback__', { value: update || misc_1.noop, writable: true });
    Object.defineProperty(target, '_update', {
        value() {
            const diff = this._diff;
            const fields = Object.keys(diff);
            if (fields.length) {
                if (label)
                    showObserverLog(`[update] ${label}: ${fields.join(', ')}`);
                this._diff = {};
                return this.__updateCallback__(diff);
            }
        },
    });
    Object.defineProperty(target, '_merge', {
        value(value) {
            for (const key in value) {
                if (!(key in this._diff)) {
                    target[key] = value[key];
                    delete this.__proxyGetters__[key];
                }
            }
            return this;
        },
    });
    const observer = observeObject(target, label, null);
    if (label)
        refs[label] = observer;
    return observer;
}
exports.observe = observe;
//# sourceMappingURL=observe.js.map
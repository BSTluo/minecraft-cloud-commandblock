"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CQCode;
(function (CQCode) {
    function escape(source, insideCQ = false) {
        const result = String(source)
            .replace(/&/g, '&amp;')
            .replace(/\[/g, '&#91;')
            .replace(/\]/g, '&#93;');
        return insideCQ
            ? result.replace(/,/g, '&#44;').replace(/(\ud83c[\udf00-\udfff])|(\ud83d[\udc00-\ude4f\ude80-\udeff])|[\u2600-\u2B55]/g, ' ')
            : result;
    }
    CQCode.escape = escape;
    function unescape(source) {
        return String(source)
            .replace(/&#91;/g, '[')
            .replace(/&#93;/g, ']')
            .replace(/&#44;/g, ',')
            .replace(/&amp;/g, '&');
    }
    CQCode.unescape = unescape;
    function stringify(type, data = {}) {
        if (type === 'text')
            return '' + data.text;
        let output = '[CQ:' + type;
        for (const key in data) {
            if (data[key])
                output += `,${key}=${escape(data[key], true)}`;
        }
        return output + ']';
    }
    CQCode.stringify = stringify;
    function stringifyAll(codes) {
        return codes.map(code => stringify(code.type, code.data)).join('');
    }
    CQCode.stringifyAll = stringifyAll;
    const regexp = /\[CQ:(\w+)((,\w+=[^,\]]*)+)\]/;
    function parse(source) {
        const capture = source.match(regexp);
        if (!capture)
            return null;
        const [_, type, attrs] = capture;
        const data = {};
        attrs.slice(1).split(/,/g).forEach((str) => {
            const index = str.indexOf('=');
            data[str.slice(0, index)] = unescape(str.slice(index + 1));
        });
        return { type, data, capture };
    }
    CQCode.parse = parse;
    function parseAll(source) {
        const codes = [];
        let result;
        while ((result = parse(source))) {
            const { capture } = result;
            if (capture.index) {
                codes.push({ type: 'text', data: { text: source.slice(0, capture.index) } });
            }
            codes.push(result);
            source = source.slice(capture.index + capture[0].length);
        }
        if (source)
            codes.push({ type: 'text', data: { text: source } });
        return codes;
    }
    CQCode.parseAll = parseAll;
})(CQCode || (CQCode = {}));
exports.default = CQCode;
//# sourceMappingURL=cqCode.js.map
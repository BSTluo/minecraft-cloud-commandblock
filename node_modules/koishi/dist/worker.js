"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const koishi_core_1 = require("koishi-core");
const path_1 = require("path");
const koishi_utils_1 = require("koishi-utils");
const perf_hooks_1 = require("perf_hooks");
const kleur_1 = require("kleur");
const utils_1 = require("./utils");
const util_1 = require("util");
const fs_1 = require("fs");
const js_yaml_1 = require("js-yaml");
const { version } = require('../package');
let baseLogLevel = 3;
if (process.env.KOISHI_LOG_LEVEL !== undefined) {
    baseLogLevel = +process.env.KOISHI_LOG_LEVEL;
}
function handleException(error) {
    utils_1.logger.error(error, baseLogLevel);
    process.exit(1);
}
process.on('uncaughtException', handleException);
const configFile = path_1.resolve(process.cwd(), process.env.KOISHI_CONFIG_FILE || 'koishi.config');
const extension = path_1.extname(configFile);
const configDir = path_1.dirname(configFile);
let config;
function tryCallback(callback) {
    try {
        return callback();
    }
    catch (error) {
        if (error.code !== 'MODULE_NOT_FOUND' && error.code !== 'ENOENT') {
            throw error;
        }
    }
}
if (['.js', '.json', '.ts'].includes(extension)) {
    config = tryCallback(() => require(configFile));
}
else if (['.yaml', '.yml'].includes(extension)) {
    config = tryCallback(() => js_yaml_1.safeLoad(fs_1.readFileSync(configFile, 'utf8')));
}
else {
    config = tryCallback(() => require(configFile))
        || tryCallback(() => js_yaml_1.safeLoad(fs_1.readFileSync(configFile + '.yml', 'utf8')))
        || tryCallback(() => js_yaml_1.safeLoad(fs_1.readFileSync(configFile + '.yaml', 'utf8')));
}
if (!config) {
    throw new Error(`config file not found. use ${kleur_1.yellow('koishi init')} command to initialize a config file.`);
}
function loadEcosystem(type, name) {
    const modules = [path_1.resolve(configDir, name)];
    const prefix = `koishi-${type}-`;
    if (name.includes(prefix)) {
        modules.push(name);
    }
    else {
        const index = name.lastIndexOf('/');
        modules.push(name.slice(0, index + 1) + prefix + name.slice(index + 1));
    }
    for (const name of modules) {
        try {
            return require(name);
        }
        catch (error) {
            if (error.code !== 'MODULE_NOT_FOUND' || error.requireStack[0] !== __filename) {
                throw error;
            }
        }
    }
    throw new Error(`cannot resolve ${type} ${name}`);
}
function loadPlugins(ctx, plugins) {
    for (const item of plugins) {
        let plugin, options;
        if (Array.isArray(item)) {
            plugin = typeof item[0] === 'string' ? loadEcosystem('plugin', item[0]) : item[0];
            options = item[1];
        }
        else if (typeof item === 'string') {
            plugin = loadEcosystem('plugin', item);
        }
        else {
            plugin = item;
        }
        ctx.plugin(plugin, options);
        if (plugin.name)
            utils_1.logger.info(`apply plugin ${kleur_1.cyan(plugin.name)}`, baseLogLevel);
    }
}
function prepareApp(config) {
    for (const name in config.database || {}) {
        const resolved = loadEcosystem('database', name);
        if (resolved)
            utils_1.logger.info(`apply database ${kleur_1.cyan(name)}`, baseLogLevel);
    }
    const app = new koishi_core_1.App(config);
    if (Array.isArray(config.plugins)) {
        loadPlugins(app, config.plugins);
    }
    else if (config.plugins && typeof config.plugins === 'object') {
        for (const path in config.plugins) {
            const ctx = app.createContext(path);
            loadPlugins(ctx, config.plugins[path]);
        }
    }
}
if (Array.isArray(config)) {
    config.forEach(conf => prepareApp(conf));
}
else {
    prepareApp(config);
}
koishi_core_1.onStart(() => {
    const versions = new Set();
    const httpPorts = new Set();
    const wsServers = new Set();
    const httpServers = new Set();
    koishi_core_1.appList.forEach((app) => {
        const { type, port, server } = app.options;
        const { coolqEdition, pluginVersion } = app.version;
        versions.add(`Koishi/${version} CoolQ/${koishi_utils_1.capitalize(coolqEdition)} CQHTTP/${pluginVersion} `);
        if (type === 'http') {
            httpPorts.add(`server listening at ${kleur_1.cyan(port)}`);
            if (server)
                httpServers.add(`connected to ${kleur_1.cyan(server)}`);
        }
        else {
            wsServers.add(`connected to ${kleur_1.cyan(server.replace(/^http/, 'ws'))}`);
        }
    });
    for (const textSet of [versions, httpPorts, wsServers, httpServers]) {
        for (const text of textSet) {
            utils_1.logger.info(text, baseLogLevel);
        }
    }
    const time = Math.max(0, perf_hooks_1.performance.now() - +process.env.KOISHI_START_TIME).toFixed();
    utils_1.logger.success(`bot started successfully in ${time} ms.`, baseLogLevel);
    process.send({ type: 'start' });
});
process.on('unhandledRejection', (error) => {
    utils_1.logger.warn(util_1.format(error), baseLogLevel);
});
koishi_core_1.appList.forEach((app) => {
    const { logLevel = 2, logFilter = {} } = app.options;
    app.receiver.on('logger', (scope, message, type) => {
        var _a;
        utils_1.logger[type](message, Math.min((_a = logFilter[scope]) !== null && _a !== void 0 ? _a : logLevel, baseLogLevel), scope);
    });
});
koishi_core_1.startAll().catch(handleException);
